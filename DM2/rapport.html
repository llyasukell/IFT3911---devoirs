<html>
    <head>
        <title>IFT3911 DM2 Équipe Bravo</title>
        <style type="text/css">
            table
            {
                border: outset 2px black;
                border-collapse: collapse;
            }
            th
            {
                border-bottom: double 2px black;
            }
            td
            {
                border-bottom: solid 1px black;
            }
            .first_col
            {
                border-right: double 2px black;
            }
            .dss-imgs
            {
                display: flex;
            }
            .dss-imgs > img
            {
                margin: 5px 10px;
            }
            img
            {
                width: 70%;
                border: 2px solid black;
                border-radius: 15px;
            }
        </style>
    </head>
    <body>
        <h1 style="text-align: center;">
            IFT 3911 - Devoir 2
        </h1>
        <h2>
            Information générale
        </h2>
        <p>
            <span style="font-weight: bold;">Nom: </span>Mattéo Caron-Mondestin
            <br />
            <span style="font-weight: bold;">Matricule: </span>20179528
            <br />
            <span style="font-weight: bold;">Courriel: </span>matteo.caron-mondestin@umontreal.ca
            <br />
            <span style="font-weight: bold;">Temps mis: </span>40 heures
        </p>
        <p>
            <span style="font-weight: bold;">Nom: </span>Mamour Ndiaye
            <br />
            <span style="font-weight: bold;">Matricule: </span>20257780
            <br />
            <span style="font-weight: bold;">Courriel: </span>mamour.ndiaye@umontreal.ca
            <br />
            <span style="font-weight: bold;">Temps mis: </span>40 heures
        </p>
        <p>
            <span style="font-weight: bold;">Nom: </span>Lisanne Duquette
            <br />
            <span style="font-weight: bold;">Matricule: </span>743198
            <br />
            <span style="font-weight: bold;">Courriel: </span>lisanne.duquette@umontreal.ca
            <br />
            <span style="font-weight: bold;">Temps mis: </span>15 heures
        </p> 
        <h2>
            Distribution des tâches
        </h2>
        <p>
            <span style="font-weight: bold;">Soumetteur: </span>Mattéo Caron-Mondestin
        </p>
        <table cellpadding="7px" border="1" style="border-collapse: collapse; text-align: center;">
            <thead>
                <tr>
                    <th class="first_col">Tâche</th>
                    <th>Mattéo</th>
                    <th>Mamour</th>
                    <th>Lisanne</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="first_col">Réseau de Pétri [25%]</td>
                    <td>0%</td>
                    <td>0%</td>
                    <td>100%</td>
                </tr>
                <tr>
                    <td class="first_col">Statechart [30%]</td>
                    <td>0%</td>
                    <td>100%</td>
                    <td>0%</td>
                </tr>
                <tr>
                    <td class="first_col">Design logiciel [25%]</td>
                    <td>100%</td>
                    <td>0</td>
                    <td>0%</td>
                </tr>
                <tr>
                    <td class="first_col">Discussion du couplage et de la cohésion des module [5%]</td>
                    <td>100%</td>
                    <td>0%</td>
                    <td>0%</td>
                </tr>
                <tr>
                    <td class="first_col">Discussion du fardeau des classes [5%]</td>
                    <td>0</td>
                    <td>100%</td>
                    <td>0%</td>
                </tr>
                <tr>
                    <td class="first_col">Graphe IA et justification [5%]</td>
                    <td>0</td>
                    <td>0</td>
                    <td>100%</td>
                </tr>
                <tr>
                    <td class="first_col">Justification de l'application des principes de conception [5%]</td>
                    <td>100%</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
            </tbody>
        </table>
        
        
        <h2>
            Tâche 1 : Réseau de Pétri
        </h2>
        <p>
            Cette tâche inclut deux volets, la modélisation d'un réseau de Pétri et son analyse.
        </p>
        <ul>
            <li>
                <h3>Modélisation du réseau de Pétri</h3>
                <p>
                    Les consignes de la modélisation étant données sous forme d'incréments, nous avons procédé en quatre étapes pour arriver à la représentation finale.<br><br>
                    Tout d'abord, nous avons représenté le tunnel et ses deux voies, avec une voie allant de Montréal (MTL) vers la Rive-Sud (SS) et une autre voie allant de la Rive-Sud (SS) vers Montréal (MTL). Nous assumons, à cette étape, que les véhicules attendent à chaque extrémité du tunnel pour y entrer et que les deux voies sont utilisées pour circuler. À la sortie, les véhicules quittent le tunnel. Le modèle résultant est un patron de parallélisme.
                </p>
                Places
                <ul>
                    <li>Entrée du tunnel à Montréal (représente la file de véhicules en attente d'entrer sur la voie de Montréal vers la Rive-Sud)</li>
                    <li>Véhicule dans le tunnel vers la Rive-Sud</li>
                    <li>Sortie du tunnel à la Rive-Sud</li>
                    <li>Entrée du tunnel à la Rive-Sud (représente la file de véhicules en attente d'entrer sur la voie de la Rive-Sud vers Montréal)</li>
                    <li>Véhicule dans le tunnel vers Montréal</li>
                    <li>Sortie du tunnel à Montréal<br><br></li>
                </ul>

                Transitions
                <ul>
                    <li>Véhicule entre dans le tunnel direction Rive-Sud</li>
                    <li>Véhicule sort du tunnel direction Rive-Sud</li>
                    <li>Véhicule entre dans le tunnel direction Montréal</li>
                    <li>Véhicule sort du tunnel direction Montréal<br><br></li>
                </ul>
                
                <img src="Petri/Images/PN_1.png" alt="Réseau de Pétri : voies circulables du tunnel">
                
                <p>
                    La deuxième étape consistait à restreindre la circulation à un véhicule à la fois dans le tunnel. Pour ce faire, nous avons ajouté une place pour l'exclusion mutuelle entre les deux voies de circulation.
                </p>
                
                <img src="Petri/Images/PN_2.png" alt="Réseau de Pétri : ajout de mutex">
                
                <p>
                    La troisième étape montre l'ajout d'un feu de circulation à deux couleurs. Lorsque le feu de circulation à l'entrée MTL du tunnel est verte, le feu est rouge à l'entrée SS et ainsi, un véhicule peut entrer dans le tunnel de Montréal vers la Rive-Sud, alors que le véhicule du côté Rive-Sud attend son tour. Lorsque le véhicule en provenance de Montréal sort du tunnel, le feu de circulation à Montréal passe au rouge et celuis de la Rive-Sud passe au vert, permettant ainsi au véhicule à l'entrée Rive-Sud de s'engager dans le tunnel.
                </p>
                Places
                <ul>
                    <li>Feu de circulation à Montréal</li>
                    <li>Feu de circulation à la Rive-Sud</li>
                    <li>Lumière rouge à Montréal</li>
                    <li>Lumière rouge à la Rive-Sud</li>
                    <li>Lumière verte à Montréal</li>
                    <li>Lumière verte à la Rive-Sud<br><br></li>
                </ul>

                Transitions
                <ul>
                    <li>Lumière devient rouge à Montréal</li>
                    <li>Lumière devient rouge à la Rive-Sud</li>
                    <li>Lumière devient verte à Montréal</li>
                    <li>Lumière devient verte à la Rive-Sud<br><br></li>
                </ul>
                
                <img src="Petri/Images/PN_3.png" alt="Réseau de Pétri : feux de circulation">
   
                <p>
                    La dernière étape demandait de rassembler les modèles élaborés dans les trois premières étapes en un seul modèle, de façon à ce que les feux de couleurs appropriées dictent le comportement des véhicules qui s'engagent ou non dans le tunnel. Nous avons ainsi ajouté les transitions appropriées entre les modèles de l'étape deux et de l'étape trois. Il en résulte le modèle final, dont le fichier est <a href="Petri/Petri net_Tunnel.xml">ici</a>
                </p>
                
                <img src="Petri/Images/PN_4.png" alt="Réseau de Pétri : modèle complet">

            <h3>Analyse du réseau de Pétri</h3>
            
            <ul>
                <li>Démontrez, à l'aide de lois de conservations, que seule une voiture peut être à l'intérieur du tunnel à la fois.</li>
                <li>Démontrez, à l'aide du graphe de couverture, que le système est équitable de part et d'autre du tunnel.</li>
                <li>Déduisez-en qu'il n'y a pas de famine dans le réseau.</li>
            </ul>
        </ul>
        
        <h2>
            Tâche 2 : Statechart
        </h2>
        <p>
            <p>Le statechart est défini sous le nom <strong>Microwave</strong> et peut être trouvé dans le fichier de remise sous ce nom.</p>

            <p>Tout d’abord, il y a la gestion de la <strong>porte</strong>, qui fonctionne en parallèle avec le processus principal. Elle a trois états : <em>Init</em>, <em>Open</em> et <em>Close</em>. Lorsque la porte est ouverte (<em>Open</em>), elle empêche la cuisson, et lorsqu’elle est fermée (<em>Close</em>), elle permet au reste du système de fonctionner normalement.</p>
            
            <p>Ensuite, dans le <strong>processus principal</strong>, on retrouve plusieurs sous-systèmes :</p>
            
            <p><strong>Power (Puissance)</strong> : Ce module gère le niveau de puissance du micro-ondes avec trois états : <em>noInput</em> (0), <em>low</em> (2) et <em>high</em> (1). L’utilisateur peut ajuster la puissance avant de démarrer la cuisson.</p>
            
            <p><strong>Timer (Minuterie)</strong> : C’est ici que le temps de cuisson est saisi. L’état <em>noTime</em> représente l’absence de temps, tandis que <em>EnteringTime</em> permet d’ajouter des chiffres jusqu’à un maximum de 4 digits.</p>
            
            <p><strong>Cook (Cuisson)</strong> : Ce module gère le fonctionnement du micro-ondes. Il démarre la cuisson lorsque les conditions sont remplies (porte fermée, temps valide) et peut passer par plusieurs états : <em>cuisson</em> (en cours), <em>pause</em> (si la cuisson est suspendue), et <em>CookStop</em> (fin de cuisson). Si la porte est ouverte en cours de cuisson, l’état <em>PorteOuvert</em> prend le relais et arrête immédiatement la cuisson.</p>
            
            <p><strong>BEEP_HANDLER (Signal sonore)</strong> : Une fois la cuisson terminée, cet état s’occupe d’émettre un bip sonore (<em>BeepOn</em> après 5 secondes).</p>
            
            <p>En résumé, la gestion de la porte fonctionne indépendamment du processus principal, mais elle influence directement la cuisson. La minuterie et la puissance permettent à l’utilisateur de régler les paramètres avant de démarrer, et le système s’assure d’arrêter la cuisson si nécessaire, tout en avertissant l’utilisateur avec un bip à la fin.</p>
            
        </p>
        <h2>
            Tâche 3 : Design logiciel
        </h2>
        <p>
            En utilisant le feedback reçu du DM1, nous avons amélioré notre diagramme de classes conceptuel, de séquences et de paquets ainsi que nos contraintes OCL. De plus, par les directives de ce devoir, nous avons appliqué les principes de conception vu en cours afin d'esquisser nos schémas et identifier les modules réutilisables dans un nouveau <a href="RevisionDM1/diagrammes.vpp">fichier vpp</a> mis à jour.
        </p> 
        <ul>
            <li>
                <h3>Révision du diagramme de classe</h3>
                <img src="RevisionDM1/images/diagramme_classes.png" alt="diagramme-de-classes">
            </li>
            <li>
                <h3>Révision des diagrammes de séquence</h3>
                <div class="dss-imgs">
                    <img src="RevisionDM1/images/dss_recherche.png" alt="dss-recherche-voyage">
                    <img src="RevisionDM1/images/dss_reservation.png" alt="dss-reserver">
                    <img src="RevisionDM1/images/dss_paiement.png" alt="dss-paiement">
                </div>
            </li>
            <li>
                <h3>Révision du diagramme de paquets</h3>
                <img src="RevisionDM1/images/diagramme_paquets.png" alt="diagramme-de-paquets">
            </li>
            <li>
                <h3>Révision des contraintes OCL</h3>
                <code>
                    # Un port est identifié par trois lettres uniques à chaque port<br>
                    context Port<br>
                    &emsp;inv:	self.id.size() = 3 and self.id.asSet().size() = 3<br>
                    &emsp;&emsp;Port.allInstances()->forAll(p1, p2 | p1 <> p2 implies p1.id <> p2.id)<br><br>

                    # La partie alphabétique de l'ID d'un vol est unique à chaque compagnie et la partie numérique est unique à chaque vol au sein de la même compagnie<br>
                    context Voyage<br>
                    &emsp;inv: self.id[1:2] is String and self.id[3:] is Interger<br><br>

                    # Une compagnie est identifiée par moins de six caractères uniques à chaque compagnie.<br>
                    context Compagnie<br>
                    &emsp;inv:	self.id = String and self.id.size() = 6<br> 
                    &emsp;&emsp;Compagnie.allInstances()->forALl(c1, c2 | c1 <> c2 implies c1.id <> c2.id)<br><br>

                    # L'aéroport de départ et d'arrivée d'un vol doit être différent<br>
                    context Vol<br>
                    &emsp;inv: self.listePorts[1] <> self.listePorts[2] and self.listePorts.size() = 2<br><br>

                    # Tous les sièges d'une même section ont le même prix<br>
                    # Toutes les cabines d'une même section ont le même prix<br>
                    context Section<br>
                    &emsp;inv: self.quartiers->forAll(q1, q2 | q1 <> q2 implies q1.prix == q2.prix)<br><br>

                    # Un itinéraire ne peut pas durer plus de 21 jours<br>
                    # Le port de départ et d'arrivée doit être le même<br>
                    # Un paquebot peut être assigné à plusieurs itinéraires tant qu'ils ne se chevauchent pas<br>
                    context Itineraire<br>
                    &emsp;inv: self.dateArrivee - self.dateDepart <= 21 jour<br>
                    &emsp;inv: self.portList[1] = self.portList[-1]<br>
                    &emsp;inv: Itineraire.allInstances()->forAll(i1, i2 |<br> 
                    &emsp;&emsp;i1.paquebot == i2.paquebot<br> 
                    &emsp;&emsp;implies i1.dateDepart > i2.dateArrivee<br>
                    &emsp;&emsp;&emsp;or i1.dateArrivee < i2.dateDepart)<br><br>

                    # Le client peut réserver un siège/cabine disponible dans un vol/trajet/itinéraire donné<br>
                    # Le client peut réserver une cabine disponible pour un itinéraire donné<br>
                    context Quartier.reserver()<br>
                    &emsp;pre: Quartier.reserve = False<br>
                    &emsp;post: Quartier.reserve = True<br><br>

                    # Un siège réservé devient assigné à un passager une fois payé: le siège est donc confirmé<br>
                    context Client::payForSeat(self.reservation)<br>
                    &emsp;post: self.reservation.seat.assigned = True<br>
                </code>
            </li>
            <li>
                <h3>Identification des modules réutilisables</h3>
                <p>Les paquets Voyage et Reservation peuvent être réutilisés par d'autres application, soit tel quel ou avec très peu d'ajustement. Le paquet Véhicule pourrait mais sûrement avec plus de modifications dépendamment de l'application. Cependant le paquet Application et UI sont spécifiques à l'implémentation du système actuel.</p>
            </li>
        </ul>
        <h2>
            Tâche 4 : Qualité du design
        </h2>
        <p>
            <ul>
                <li>
                    <h3>Discussion du couplage et de la cohésion des modules</h3>
                    <p>
                        En utilisant des énumérations nous avons réduit la sophistication du diagramme, permettant une extension et modification simple. Le couplage a été réduit en protégeant le contenu des classes, en utilisant des méthodes set/get et en évitant les paramètres de contrôle.
                        <br>
                        Les modules sont convenablement séparés où possible afin d'augmenter la cohésion, par exemple avec l'ajout de la classe Paiement, pour éviter la cohésion logique, et des interfaces GestionObjet, pour la cohésion communicationnelle, et Réservable pour la cohésion fonctionnelle, que nous avons omises dans notre première version.
                    </p>
                </li>
                <li>
                    <h3>Discussion du fardeau des classes</h3>
                    <p>
                        Train {Vehicule, Section, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 9 <br>
                        Avion {Vehicule, Section, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 9 <br>
                        Paquebot {Vehicule, Section, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 9 <br>
                        Vehicule {Section, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 8 <br>
                        Section {Vehicule, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 8 <br>
                        Quartier {Vehicule, Section, String, Integer, Float, Boolean, Reservable, GestionObjet} = 8 <br>
                        Siege {Quartier, ClasseSiege, String, Integer, Boolean, Float, Section, Vehicule, Reservable, GestionObjet} = 10 <br>
                        Cabine {Quartier, ClasseCabine, String, Integer, Boolean, Float, Section, Vehicule, Reservable, GestionObjet} = 10 <br>
                        SectionAvion {Section, ClasseSiege, Vehicule, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 10 <br>
                        SectionPaquebot {Section, ClasseCabine, Vehicule, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 10 <br>
                        SectionTrain {Section, ClasseSiege, Vehicule, Quartier, String, Integer, Float, Boolean, GestionObjet, Reservable} = 10 <br>
                        Reservable {} = 0 <br><br>
                    
                        <strong>&lt;&lt;Enumeration&gt;&gt;</strong> <br>
                        PortType {} = 0 <br>
                        ClasseSiege {} = 0 <br>
                        ClasseCabine {} = 0 <br>
                        DispositionSection {} = 0 <br><br>
                    
                        GestionObjet {} = 0 <br>
                        Port {GestionObjet, String, PortType} = 3 <br>
                        Criteres {Date, ClasseSiege, ClasseCabine, Port, GestionObjet, String, PortType, Voyage} = 8 <br>
                        VueClient {} = 0 <br>
                        VueAdmin {} = 0 <br>
                        BaseDeDonnees {} = 0 <br>
                        Systeme {Criteres, Date, ClasseSiege, ClasseCabine, Port, GestionObjet, String, PortType, Voyage} = 8 <br>
                        Voyage {Port, GestionObjet, String, Date, PortType} = 5 <br>
                        Client {String} = 1 <br>
                        Vol {Voyage, Port, GestionObjet, String, Date, PortType} = 6 <br>
                        Trajet {Voyage, Port, GestionObjet, String, Date, PortType} = 6 <br>
                        Itineraire {Voyage, Port, GestionObjet, String, Date, PortType} = 6 <br>
                        Compagnie {String, Float} = 2 <br>
                        Paiement {} = 0 <br>
                        Reservation {Integer, Boolean, Date} = 3 <br>
                    </p>
                    <p>
                        En analysant le fardeau des classes, on remarque que certaines classes ont un nombre de dépendances très élevé, ce qui signifie qu'elles sont fortement liées à d'autres classes du système.  
                        <br><br>
                        Les classes avec le fardeau le plus élevé sont (Siege, Cabine, SectionAvion, SectionPaquebot et SectionTrain), avec une valeur de 10. Cela s'explique par le fait qu'elles dépendent de nombreuses autres classes comme **Quartier, Section, Vehicule, GestionObjet, Reservable, et plusieurs types de données primaires**. Ces classes jouent un rôle central dans la gestion des sièges et cabines des différents modes de transport.  
                        <br><br>
                        Ensuite, on retrouve les classes (Train, Avion et Paquebot) avec un fardeau de 9, car elles héritent de Vehicule et dépendent également de Section, Quartier, et plusieurs autres classes. Cela montre que ces classes sont essentielles pour définir les différents types de transport.  
                        <br><br>
                        D'autres classes comme Systeme et Criteres ont un fardeau de 8, car elles interagissent avec plusieurs éléments du système, notamment en ce qui concerne la gestion des critères et des voyages.  
                        <br><br>
                        À l'inverse, certaines classes ont un fardeau très faible ou nul, comme Reservable, VueClient, VueAdmin, BaseDeDonnees, Paiement, et les énumérations (PortType, ClasseSiege, ClasseCabine, DispositionSection), qui ne dépendent d'aucune autre classe.  
                        <br><br>
                        
                    </p>
                </li>
                <li>
                    <h3>Graphe IA et justification</h3>
                    <p>
                        Le graphe IA est construit à partir de la relation entre la stabilité et l'abstraction des packages.
                    </p>
                Stabilité (I = couplage efférent / (couplage afférent + couplage efférent))
                <ul>
                    <li>Paquet UI : C<sub>e</sub> = 2 et C<sub>a</sub> = 0, donc I = 1</li>
                    <li>Paquet Réservation : C<sub>e</sub> = 0 et C<sub>a</sub> = 1, donc I = 0</li>
                    <li>Paquet Application : C<sub>e</sub> = 1 et C<sub>a</sub> = 1, donc I = 0,5</li>
                    <li>Paquet Voyage : C<sub>e</sub> = 1 et C<sub>a</sub> = 1, donc I = 0,5</li>
                    <li>Paquet Véhicule : C<sub>e</sub> = 0 et C<sub>a</sub> = 1, donc I = 0<br><br></li>
                </ul>

                Abstraction (A = nombre de classes abstraites dans le package / nombre de classes total dans le package)
                <ul>
                    <li>Paquet UI : N<sub>a</sub> = 0 et N<sub>c</sub> = 2, donc A = 0</li>
                    <li>Paquet Réservation : N<sub>a</sub> = 0 et N<sub>c</sub> = 4, donc A = 0</li>
                    <li>Paquet Application : N<sub>a</sub> = 0 et N<sub>c</sub> = 4, donc A = 0</li>
                    <li>Paquet Voyage : N<sub>a</sub> = 1 et N<sub>c</sub> = 6, donc A = 0,17</li>
                    <li>Paquet Véhicule : N<sub>a</sub> = 2 et N<sub>c</sub> = 11, donc A = 0,18<br><br></li>
                </ul>
                <p>
                    Il en résulte le graphe IA suivant :
                </p>
                <img src="RevisionDM1/images/GrapheIA.png" alt="Graphe IA">
                <p>
                    On peut y voir que nous aurions intérêt à augmenter l'équilibre entre la stabilité et l'abstraction, car les points du graphe se trouvent près de la "Zone of Pain". Cela signifie que les composantes stables ne sont pas abstraites et que des changements dans l'implémentation pourraient impacter de grandes portions du code.
                </p>
                </li>
                <li>
                    <h3>Justification de l'application des principes de conception</h3>
                    <p>
                        LSP respecté. Les sous-classes de l'application ont toutes un comportement conforme à la hiérarchie de classes (un avion se comporte comme un véhicule et une cabine se comporte comme un quartier par exemple).
                        <br>
                        Afin de respecter le principe Open/Closed, nous avons créé les classes abstraites Voyage, Véhicule, Section et Quartier, dont le comportement pourrait être étendu par des sous classes. Par contre, malgré que l'énoncé implique plusieurs types de compagnies, nous avons opté pour une classe simple pour signifier la possibilité qu'une compagnie offre <e>plusieurs</e> types de voyages.
                        <br>
                        Les interfaces GestionObjet et Réservable, ainsi que les classes abstraites mentionnées plus haut, interviennent pour respecter le principe d'inversion de dépendance. Ceci assure la réutilisabilité des modules.
                        <br>
                        La distinction entre VueAdmin et VueClient permet de suivre le principe de responsabilité unique et de ségrégation d'interfaces malgré le fait que les deux ont des méthodes similaires. Ceci permet de séparer leur comportement et assure que des changements n'affectent pas l'autre accidentellement.
                        <br>
                        Le principe de réutilisation composite se voit dans la création de la classe Section par exemple, qui aurait pu être implémentée directement dans les objets Véhicules différemment des sous-classes. Cette façon de faire permet de réutiliser le code et même de l'étendre si besoin.
                    </p>
                </li>
            </ul>
        </p>
    </body>
</html>
